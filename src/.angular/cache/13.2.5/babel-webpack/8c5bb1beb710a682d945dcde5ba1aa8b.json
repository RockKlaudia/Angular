{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport { ReplaySubject, Subject, BehaviorSubject, interval } from 'rxjs';\nimport { switchMap, filter, tap, take } from 'rxjs/operators';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\nfunction BoardComponent_div_0_ngx_snake_tile_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngx-snake-tile\", 3);\n  }\n\n  if (rf & 2) {\n    const tileState_r3 = ctx.$implicit;\n    i0.ɵɵproperty(\"state\", tileState_r3);\n  }\n}\n\nfunction BoardComponent_div_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵtemplate(1, BoardComponent_div_0_ngx_snake_tile_1_Template, 1, 1, \"ngx-snake-tile\", 2);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const row_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", row_r1);\n  }\n}\n\nvar GameState;\n\n(function (GameState) {\n  GameState[GameState[\"Paused\"] = 0] = \"Paused\";\n  GameState[GameState[\"Started\"] = 1] = \"Started\";\n  GameState[GameState[\"Over\"] = 2] = \"Over\";\n})(GameState || (GameState = {}));\n\nvar TileState;\n\n(function (TileState) {\n  TileState[\"Free\"] = \"free\";\n  TileState[\"Head\"] = \"head\";\n  TileState[\"Body\"] = \"body\";\n  TileState[\"Tail\"] = \"tail\";\n  TileState[\"Wall\"] = \"wall\";\n  TileState[\"Food\"] = \"food\";\n})(TileState || (TileState = {}));\n\nvar MoveDirections;\n\n(function (MoveDirections) {\n  MoveDirections[MoveDirections[\"UP\"] = 0] = \"UP\";\n  MoveDirections[MoveDirections[\"RIGHT\"] = 1] = \"RIGHT\";\n  MoveDirections[MoveDirections[\"DOWN\"] = 2] = \"DOWN\";\n  MoveDirections[MoveDirections[\"LEFT\"] = 3] = \"LEFT\";\n})(MoveDirections || (MoveDirections = {}));\n\nclass GameManagerService {\n  constructor() {\n    this._grid = [];\n    this._grid$ = new ReplaySubject(1);\n    this.grid$ = this._grid$.asObservable();\n    this._gameOver$ = new Subject();\n    this.gameOver$ = this._gameOver$;\n    this._foodEaten$ = new Subject();\n    this.foodEaten$ = this._foodEaten$;\n    this._gridSize = {\n      h: 10,\n      w: 10\n    };\n    this._snake = [];\n    this._nextMoveDir = MoveDirections.RIGHT;\n    this._moveDir = MoveDirections.RIGHT;\n    this._food = null;\n    this._interval$ = new BehaviorSubject(700);\n    this._paused = true;\n    this._playable = true;\n    this.signal$ = this._interval$.asObservable().pipe(switchMap(period => interval(period)), filter(() => !this._paused), tap(() => this._gameCycle()));\n  }\n\n  initialize(height, width) {\n    this._gridSize.w = width;\n    this._gridSize.h = height;\n\n    this._buildEmptyGrid();\n\n    this._initSnake();\n\n    this._drawSnake();\n\n    this._gridChanged();\n\n    this.signal$.subscribe(() => {});\n  }\n\n  start() {\n    if (this._playable) {\n      this._paused = false;\n    }\n  }\n\n  changeSpeed(period) {\n    this._interval$.next(period);\n  }\n\n  pause() {\n    this._paused = true;\n  }\n\n  reset() {\n    this.pause();\n    this._playable = true;\n    this._moveDir = MoveDirections.RIGHT;\n    this._nextMoveDir = this._moveDir;\n\n    this._buildEmptyGrid();\n\n    this._initSnake();\n\n    this._drawSnake();\n\n    this._gridChanged();\n  }\n\n  up() {\n    this._moveDir !== MoveDirections.DOWN ? this._nextMoveDir = MoveDirections.UP : this._moveDir;\n  }\n\n  right() {\n    this._moveDir !== MoveDirections.LEFT ? this._nextMoveDir = MoveDirections.RIGHT : this._moveDir;\n  }\n\n  down() {\n    this._moveDir !== MoveDirections.UP ? this._nextMoveDir = MoveDirections.DOWN : this._moveDir;\n  }\n\n  left() {\n    this._moveDir !== MoveDirections.RIGHT ? this._nextMoveDir = MoveDirections.LEFT : this._moveDir;\n  }\n\n  _endGame() {\n    this._playable = false;\n    this.pause();\n\n    this._gameOver$.next();\n  }\n\n  _buildEmptyGrid() {\n    const newGrid = [];\n\n    for (let y = 0; y <= this._gridSize.h; y++) {\n      const row = [];\n\n      for (let x = 0; x <= this._gridSize.w; x++) {\n        row.push(TileState.Free);\n      }\n\n      newGrid.push(row);\n    }\n\n    this._grid = newGrid;\n  }\n\n  _gridChanged() {\n    this._grid$.next(this._grid);\n  }\n\n  _initSnake() {\n    this._snake = [];\n    const xCenter = Math.floor(this._gridSize.w / 2);\n    const yCenter = Math.floor(this._gridSize.h / 2);\n\n    this._snake.push({\n      x: xCenter,\n      y: yCenter\n    });\n\n    this._snake.push({\n      x: xCenter - 1,\n      y: yCenter\n    });\n\n    this._snake.push({\n      x: xCenter - 2,\n      y: yCenter\n    });\n  }\n\n  _spawnFood() {\n    if (!this._food) {\n      const eligibleFields = [];\n\n      for (let y = 1; y <= this._gridSize.h - 1; y++) {\n        for (let x = 1; x <= this._gridSize.w - 1; x++) {\n          if (this._grid[y][x] === TileState.Free) {\n            eligibleFields.push({\n              x,\n              y\n            });\n          }\n        }\n      }\n\n      const shuffled = eligibleFields.sort((a, b) => 0.5 - Math.random());\n      this._food = shuffled[0];\n    }\n\n    this._grid[this._food.y][this._food.x] = TileState.Food;\n  }\n\n  _drawSnake() {\n    const head = this._snake[0];\n    const tail = this._snake[this._snake.length - 1];\n    this._grid[head.y][head.x] = TileState.Head;\n\n    for (let i = 1; i < this._snake.length - 1; i++) {\n      const part = this._snake[i];\n      this._grid[part.y][part.x] = TileState.Body;\n    }\n\n    this._grid[tail.y][tail.x] = TileState.Tail;\n  }\n\n  _gameCycle() {\n    const head = this._snake[0];\n    let newHead;\n    this._moveDir = this._nextMoveDir;\n\n    if (this._moveDir === MoveDirections.UP) {\n      newHead = {\n        x: head.x,\n        y: head.y - 1\n      };\n    } else if (this._moveDir === MoveDirections.RIGHT) {\n      newHead = {\n        x: head.x + 1,\n        y: head.y\n      };\n    } else if (this._moveDir === MoveDirections.DOWN) {\n      newHead = {\n        x: head.x,\n        y: head.y + 1\n      };\n    } else {\n      // Moving left\n      newHead = {\n        x: head.x - 1,\n        y: head.y\n      };\n    }\n\n    if (this._willCrash(newHead)) {\n      return this._endGame();\n    } // position new head\n\n\n    this._snake.unshift(newHead);\n\n    if (this._willGrow(newHead)) {\n      this._increaseSpeed();\n\n      this._foodEaten$.next();\n\n      this._food = null;\n    } else {\n      // drop old tail\n      this._snake.pop();\n    }\n\n    this._buildEmptyGrid();\n\n    this._drawSnake();\n\n    this._spawnFood();\n\n    this._gridChanged();\n  }\n  /**\n   * Checks if field is not currently occupied (is free to take)\n   * @param newHead\n   * @private\n   */\n\n\n  _willCrash(newHead) {\n    // Gets out of the board\n    if (newHead.x < 0 || newHead.y < 0 || newHead.x > this._gridSize.w || newHead.y > this._gridSize.h) {\n      return true;\n    }\n\n    const CRASHABLE_FIELDS = [TileState.Body, TileState.Wall];\n\n    if (CRASHABLE_FIELDS.includes(this._grid[newHead.y][newHead.x])) {\n      return true;\n    } // If crashing with tail then check if tail will move...\n\n\n    if (this._grid[newHead.y][newHead.x] === TileState.Tail && this._willGrow(newHead)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  _willGrow(newHead) {\n    if (this._food && this._food.y === newHead.y && this._food.x === newHead.x) {\n      return true;\n    }\n\n    return false;\n  }\n\n  _increaseSpeed() {\n    this._interval$.pipe(take(1)).subscribe(current => {\n      if (current >= 600) {\n        this._interval$.next(current - 100);\n      } else if (current >= 500) {\n        this._interval$.next(current - 30);\n      } else if (current >= 400) {\n        this._interval$.next(current - 20);\n      } else {\n        this._interval$.next(current - 10);\n      }\n    });\n  }\n\n}\n\nGameManagerService.ɵfac = function GameManagerService_Factory(t) {\n  return new (t || GameManagerService)();\n};\n\nGameManagerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: GameManagerService,\n  factory: GameManagerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(GameManagerService, [{\n    type: Injectable\n  }], null, null);\n})();\n\nclass TileComponent {\n  constructor(el, _renderer) {\n    this.el = el;\n    this._renderer = _renderer;\n  }\n\n  ngOnInit() {\n    if (this.state) {\n      this._renderer.addClass(this.el.nativeElement, this.state);\n    }\n  }\n\n}\n\nTileComponent.ɵfac = function TileComponent_Factory(t) {\n  return new (t || TileComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2));\n};\n\nTileComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: TileComponent,\n  selectors: [[\"ngx-snake-tile\"]],\n  inputs: {\n    state: \"state\"\n  },\n  decls: 1,\n  vars: 0,\n  template: function TileComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"div\");\n    }\n  },\n  styles: [\"ngx-snake-tile{display:block;background:#ccf1ed;border:1px solid #4e4645;width:25px;height:25px;float:left;margin:1px;box-sizing:border-box}ngx-snake-tile div{height:100%;width:100%;display:block;background:#ccf1ed}ngx-snake-tile.free div{background:#ccf1ed}ngx-snake-tile.head div{background:#4e6c31}ngx-snake-tile.body div{background:#4e6c31}ngx-snake-tile.tail div{background:#4e6c31}ngx-snake-tile.wall div{background:#C2C3C7}ngx-snake-tile.food{padding:3px}ngx-snake-tile.food div{background:#00E436}\\n\"],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TileComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-snake-tile',\n      template: `<div></div>`,\n      encapsulation: ViewEncapsulation.None,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      styles: [\"ngx-snake-tile{display:block;background:#ccf1ed;border:1px solid #4e4645;width:25px;height:25px;float:left;margin:1px;box-sizing:border-box}ngx-snake-tile div{height:100%;width:100%;display:block;background:#ccf1ed}ngx-snake-tile.free div{background:#ccf1ed}ngx-snake-tile.head div{background:#4e6c31}ngx-snake-tile.body div{background:#4e6c31}ngx-snake-tile.tail div{background:#4e6c31}ngx-snake-tile.wall div{background:#C2C3C7}ngx-snake-tile.food{padding:3px}ngx-snake-tile.food div{background:#00E436}\\n\"]\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }];\n  }, {\n    state: [{\n      type: Input\n    }]\n  });\n})();\n\nclass BoardComponent {\n  constructor() {}\n\n  ngOnInit() {}\n\n}\n\nBoardComponent.ɵfac = function BoardComponent_Factory(t) {\n  return new (t || BoardComponent)();\n};\n\nBoardComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: BoardComponent,\n  selectors: [[\"ngx-snake-board\"]],\n  inputs: {\n    data: \"data\"\n  },\n  decls: 1,\n  vars: 1,\n  consts: [[\"class\", \"ngx-snake-board-row\", 4, \"ngFor\", \"ngForOf\"], [1, \"ngx-snake-board-row\"], [3, \"state\", 4, \"ngFor\", \"ngForOf\"], [3, \"state\"]],\n  template: function BoardComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, BoardComponent_div_0_Template, 2, 1, \"div\", 0);\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"ngForOf\", ctx.data);\n    }\n  },\n  directives: [TileComponent, i2.NgForOf],\n  styles: [\"[_nghost-%COMP%]   .ngx-snake-board-row[_ngcontent-%COMP%]{display:block;clear:both}\"]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BoardComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-snake-board',\n      template: \"<div class=\\\"ngx-snake-board-row\\\" *ngFor=\\\"let row of data\\\">\\n    <ngx-snake-tile *ngFor=\\\"let tileState of row\\\"\\n                    [state]=\\\"tileState\\\"></ngx-snake-tile>\\n</div>\\n\",\n      styles: [\":host .ngx-snake-board-row{display:block;clear:both}\\n\"]\n    }]\n  }], function () {\n    return [];\n  }, {\n    data: [{\n      type: Input\n    }]\n  });\n})();\n\nclass NgxSnakeComponent {\n  constructor(_manager) {\n    this._manager = _manager;\n    this.boardHeight = 10;\n    this.boardWidth = 10;\n    this.foodEaten = this._manager.foodEaten$;\n    this.gameOver = this._manager.gameOver$;\n    this.grid$ = this._manager.grid$;\n  }\n\n  ngOnInit() {\n    this._manager.initialize(this.boardHeight, this.boardWidth);\n  }\n\n  actionUp() {\n    this._manager.up();\n  }\n\n  actionRight() {\n    this._manager.right();\n  }\n\n  actionDown() {\n    this._manager.down();\n  }\n\n  actionLeft() {\n    this._manager.left();\n  }\n\n  actionStart() {\n    this._manager.start();\n  }\n\n  actionStop() {\n    this._manager.pause();\n  }\n\n  actionReset() {\n    this._manager.reset();\n  }\n\n}\n\nNgxSnakeComponent.ɵfac = function NgxSnakeComponent_Factory(t) {\n  return new (t || NgxSnakeComponent)(i0.ɵɵdirectiveInject(GameManagerService));\n};\n\nNgxSnakeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NgxSnakeComponent,\n  selectors: [[\"ngx-snake\"]],\n  inputs: {\n    boardHeight: \"boardHeight\",\n    boardWidth: \"boardWidth\"\n  },\n  outputs: {\n    foodEaten: \"foodEaten\",\n    gameOver: \"gameOver\"\n  },\n  decls: 2,\n  vars: 3,\n  consts: [[3, \"data\"]],\n  template: function NgxSnakeComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelement(0, \"ngx-snake-board\", 0);\n      i0.ɵɵpipe(1, \"async\");\n    }\n\n    if (rf & 2) {\n      i0.ɵɵproperty(\"data\", i0.ɵɵpipeBind1(1, 1, ctx.grid$));\n    }\n  },\n  directives: [BoardComponent],\n  pipes: [i2.AsyncPipe],\n  encapsulation: 2\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxSnakeComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ngx-snake',\n      template: `\n        <ngx-snake-board\n            [data]=\"grid$ | async\"></ngx-snake-board>\n    `,\n      styles: []\n    }]\n  }], function () {\n    return [{\n      type: GameManagerService\n    }];\n  }, {\n    boardHeight: [{\n      type: Input\n    }],\n    boardWidth: [{\n      type: Input\n    }],\n    foodEaten: [{\n      type: Output\n    }],\n    gameOver: [{\n      type: Output\n    }]\n  });\n})();\n\nclass NgxSnakeModule {\n  static forRoot() {\n    return {\n      ngModule: NgxSnakeModule\n    };\n  }\n\n}\n\nNgxSnakeModule.ɵfac = function NgxSnakeModule_Factory(t) {\n  return new (t || NgxSnakeModule)();\n};\n\nNgxSnakeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NgxSnakeModule\n});\nNgxSnakeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [GameManagerService],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxSnakeModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NgxSnakeComponent, BoardComponent, TileComponent],\n      imports: [CommonModule],\n      providers: [GameManagerService],\n      exports: [NgxSnakeComponent]\n    }]\n  }], null, null);\n})();\n/*\n * Public API Surface of ngx-snake\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NgxSnakeComponent, NgxSnakeModule };","map":{"version":3,"sources":["C:/Users/Klaudia/angular_project_KS/angular-projekt-ks/node_modules/ngx-snake/fesm2015/ngx-snake.mjs"],"names":["i0","Injectable","Component","ViewEncapsulation","ChangeDetectionStrategy","Input","Output","NgModule","ReplaySubject","Subject","BehaviorSubject","interval","switchMap","filter","tap","take","i2","CommonModule","GameState","TileState","MoveDirections","GameManagerService","constructor","_grid","_grid$","grid$","asObservable","_gameOver$","gameOver$","_foodEaten$","foodEaten$","_gridSize","h","w","_snake","_nextMoveDir","RIGHT","_moveDir","_food","_interval$","_paused","_playable","signal$","pipe","period","_gameCycle","initialize","height","width","_buildEmptyGrid","_initSnake","_drawSnake","_gridChanged","subscribe","start","changeSpeed","next","pause","reset","up","DOWN","UP","right","LEFT","down","left","_endGame","newGrid","y","row","x","push","Free","xCenter","Math","floor","yCenter","_spawnFood","eligibleFields","shuffled","sort","a","b","random","Food","head","tail","length","Head","i","part","Body","Tail","newHead","_willCrash","unshift","_willGrow","_increaseSpeed","pop","CRASHABLE_FIELDS","Wall","includes","current","ɵfac","ɵprov","type","TileComponent","el","_renderer","ngOnInit","state","addClass","nativeElement","ElementRef","Renderer2","ɵcmp","args","selector","template","encapsulation","None","changeDetection","OnPush","styles","BoardComponent","NgForOf","data","NgxSnakeComponent","_manager","boardHeight","boardWidth","foodEaten","gameOver","actionUp","actionRight","actionDown","actionLeft","actionStart","actionStop","actionReset","AsyncPipe","NgxSnakeModule","forRoot","ngModule","ɵmod","ɵinj","declarations","imports","providers","exports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport { ReplaySubject, Subject, BehaviorSubject, interval } from 'rxjs';\nimport { switchMap, filter, tap, take } from 'rxjs/operators';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\nvar GameState;\n(function (GameState) {\n    GameState[GameState[\"Paused\"] = 0] = \"Paused\";\n    GameState[GameState[\"Started\"] = 1] = \"Started\";\n    GameState[GameState[\"Over\"] = 2] = \"Over\";\n})(GameState || (GameState = {}));\nvar TileState;\n(function (TileState) {\n    TileState[\"Free\"] = \"free\";\n    TileState[\"Head\"] = \"head\";\n    TileState[\"Body\"] = \"body\";\n    TileState[\"Tail\"] = \"tail\";\n    TileState[\"Wall\"] = \"wall\";\n    TileState[\"Food\"] = \"food\";\n})(TileState || (TileState = {}));\nvar MoveDirections;\n(function (MoveDirections) {\n    MoveDirections[MoveDirections[\"UP\"] = 0] = \"UP\";\n    MoveDirections[MoveDirections[\"RIGHT\"] = 1] = \"RIGHT\";\n    MoveDirections[MoveDirections[\"DOWN\"] = 2] = \"DOWN\";\n    MoveDirections[MoveDirections[\"LEFT\"] = 3] = \"LEFT\";\n})(MoveDirections || (MoveDirections = {}));\n\nclass GameManagerService {\n    constructor() {\n        this._grid = [];\n        this._grid$ = new ReplaySubject(1);\n        this.grid$ = this._grid$.asObservable();\n        this._gameOver$ = new Subject();\n        this.gameOver$ = this._gameOver$;\n        this._foodEaten$ = new Subject();\n        this.foodEaten$ = this._foodEaten$;\n        this._gridSize = {\n            h: 10,\n            w: 10\n        };\n        this._snake = [];\n        this._nextMoveDir = MoveDirections.RIGHT;\n        this._moveDir = MoveDirections.RIGHT;\n        this._food = null;\n        this._interval$ = new BehaviorSubject(700);\n        this._paused = true;\n        this._playable = true;\n        this.signal$ = this._interval$\n            .asObservable()\n            .pipe(switchMap((period) => interval(period)), filter(() => !this._paused), tap(() => this._gameCycle()));\n    }\n    initialize(height, width) {\n        this._gridSize.w = width;\n        this._gridSize.h = height;\n        this._buildEmptyGrid();\n        this._initSnake();\n        this._drawSnake();\n        this._gridChanged();\n        this.signal$.subscribe(() => {\n        });\n    }\n    start() {\n        if (this._playable) {\n            this._paused = false;\n        }\n    }\n    changeSpeed(period) {\n        this._interval$.next(period);\n    }\n    pause() {\n        this._paused = true;\n    }\n    reset() {\n        this.pause();\n        this._playable = true;\n        this._moveDir = MoveDirections.RIGHT;\n        this._nextMoveDir = this._moveDir;\n        this._buildEmptyGrid();\n        this._initSnake();\n        this._drawSnake();\n        this._gridChanged();\n    }\n    up() { this._moveDir !== MoveDirections.DOWN ? this._nextMoveDir = MoveDirections.UP : this._moveDir; }\n    right() { this._moveDir !== MoveDirections.LEFT ? this._nextMoveDir = MoveDirections.RIGHT : this._moveDir; }\n    down() { this._moveDir !== MoveDirections.UP ? this._nextMoveDir = MoveDirections.DOWN : this._moveDir; }\n    left() { this._moveDir !== MoveDirections.RIGHT ? this._nextMoveDir = MoveDirections.LEFT : this._moveDir; }\n    _endGame() {\n        this._playable = false;\n        this.pause();\n        this._gameOver$.next();\n    }\n    _buildEmptyGrid() {\n        const newGrid = [];\n        for (let y = 0; y <= this._gridSize.h; y++) {\n            const row = [];\n            for (let x = 0; x <= this._gridSize.w; x++) {\n                row.push(TileState.Free);\n            }\n            newGrid.push(row);\n        }\n        this._grid = newGrid;\n    }\n    _gridChanged() {\n        this._grid$.next(this._grid);\n    }\n    _initSnake() {\n        this._snake = [];\n        const xCenter = Math.floor(this._gridSize.w / 2);\n        const yCenter = Math.floor(this._gridSize.h / 2);\n        this._snake.push({ x: xCenter, y: yCenter });\n        this._snake.push({ x: xCenter - 1, y: yCenter });\n        this._snake.push({ x: xCenter - 2, y: yCenter });\n    }\n    _spawnFood() {\n        if (!this._food) {\n            const eligibleFields = [];\n            for (let y = 1; y <= this._gridSize.h - 1; y++) {\n                for (let x = 1; x <= this._gridSize.w - 1; x++) {\n                    if (this._grid[y][x] === TileState.Free) {\n                        eligibleFields.push({\n                            x, y\n                        });\n                    }\n                }\n            }\n            const shuffled = eligibleFields.sort((a, b) => 0.5 - Math.random());\n            this._food = shuffled[0];\n        }\n        this._grid[this._food.y][this._food.x] = TileState.Food;\n    }\n    _drawSnake() {\n        const head = this._snake[0];\n        const tail = this._snake[this._snake.length - 1];\n        this._grid[head.y][head.x] = TileState.Head;\n        for (let i = 1; i < this._snake.length - 1; i++) {\n            const part = this._snake[i];\n            this._grid[part.y][part.x] = TileState.Body;\n        }\n        this._grid[tail.y][tail.x] = TileState.Tail;\n    }\n    _gameCycle() {\n        const head = this._snake[0];\n        let newHead;\n        this._moveDir = this._nextMoveDir;\n        if (this._moveDir === MoveDirections.UP) {\n            newHead = { x: head.x, y: head.y - 1 };\n        }\n        else if (this._moveDir === MoveDirections.RIGHT) {\n            newHead = { x: head.x + 1, y: head.y };\n        }\n        else if (this._moveDir === MoveDirections.DOWN) {\n            newHead = { x: head.x, y: head.y + 1 };\n        }\n        else {\n            // Moving left\n            newHead = { x: head.x - 1, y: head.y };\n        }\n        if (this._willCrash(newHead)) {\n            return this._endGame();\n        }\n        // position new head\n        this._snake.unshift(newHead);\n        if (this._willGrow(newHead)) {\n            this._increaseSpeed();\n            this._foodEaten$.next();\n            this._food = null;\n        }\n        else {\n            // drop old tail\n            this._snake.pop();\n        }\n        this._buildEmptyGrid();\n        this._drawSnake();\n        this._spawnFood();\n        this._gridChanged();\n    }\n    /**\n     * Checks if field is not currently occupied (is free to take)\n     * @param newHead\n     * @private\n     */\n    _willCrash(newHead) {\n        // Gets out of the board\n        if (newHead.x < 0 || newHead.y < 0 || newHead.x > this._gridSize.w || newHead.y > this._gridSize.h) {\n            return true;\n        }\n        const CRASHABLE_FIELDS = [\n            TileState.Body,\n            TileState.Wall\n        ];\n        if (CRASHABLE_FIELDS.includes(this._grid[newHead.y][newHead.x])) {\n            return true;\n        }\n        // If crashing with tail then check if tail will move...\n        if (this._grid[newHead.y][newHead.x] === TileState.Tail && this._willGrow(newHead)) {\n            return true;\n        }\n        return false;\n    }\n    _willGrow(newHead) {\n        if (this._food && this._food.y === newHead.y && this._food.x === newHead.x) {\n            return true;\n        }\n        return false;\n    }\n    _increaseSpeed() {\n        this._interval$\n            .pipe(take(1))\n            .subscribe((current) => {\n            if (current >= 600) {\n                this._interval$.next(current - 100);\n            }\n            else if (current >= 500) {\n                this._interval$.next(current - 30);\n            }\n            else if (current >= 400) {\n                this._interval$.next(current - 20);\n            }\n            else {\n                this._interval$.next(current - 10);\n            }\n        });\n    }\n}\nGameManagerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: GameManagerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nGameManagerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: GameManagerService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: GameManagerService, decorators: [{\n            type: Injectable\n        }] });\n\nclass TileComponent {\n    constructor(el, _renderer) {\n        this.el = el;\n        this._renderer = _renderer;\n    }\n    ngOnInit() {\n        if (this.state) {\n            this._renderer.addClass(this.el.nativeElement, this.state);\n        }\n    }\n}\nTileComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: TileComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Component });\nTileComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.0.1\", type: TileComponent, selector: \"ngx-snake-tile\", inputs: { state: \"state\" }, ngImport: i0, template: `<div></div>`, isInline: true, styles: [\"ngx-snake-tile{display:block;background:#ccf1ed;border:1px solid #4e4645;width:25px;height:25px;float:left;margin:1px;box-sizing:border-box}ngx-snake-tile div{height:100%;width:100%;display:block;background:#ccf1ed}ngx-snake-tile.free div{background:#ccf1ed}ngx-snake-tile.head div{background:#4e6c31}ngx-snake-tile.body div{background:#4e6c31}ngx-snake-tile.tail div{background:#4e6c31}ngx-snake-tile.wall div{background:#C2C3C7}ngx-snake-tile.food{padding:3px}ngx-snake-tile.food div{background:#00E436}\\n\"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: TileComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-snake-tile', template: `<div></div>`, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [\"ngx-snake-tile{display:block;background:#ccf1ed;border:1px solid #4e4645;width:25px;height:25px;float:left;margin:1px;box-sizing:border-box}ngx-snake-tile div{height:100%;width:100%;display:block;background:#ccf1ed}ngx-snake-tile.free div{background:#ccf1ed}ngx-snake-tile.head div{background:#4e6c31}ngx-snake-tile.body div{background:#4e6c31}ngx-snake-tile.tail div{background:#4e6c31}ngx-snake-tile.wall div{background:#C2C3C7}ngx-snake-tile.food{padding:3px}ngx-snake-tile.food div{background:#00E436}\\n\"] }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }]; }, propDecorators: { state: [{\n                type: Input\n            }] } });\n\nclass BoardComponent {\n    constructor() {\n    }\n    ngOnInit() {\n    }\n}\nBoardComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: BoardComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });\nBoardComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.0.1\", type: BoardComponent, selector: \"ngx-snake-board\", inputs: { data: \"data\" }, ngImport: i0, template: \"<div class=\\\"ngx-snake-board-row\\\" *ngFor=\\\"let row of data\\\">\\n    <ngx-snake-tile *ngFor=\\\"let tileState of row\\\"\\n                    [state]=\\\"tileState\\\"></ngx-snake-tile>\\n</div>\\n\", styles: [\":host .ngx-snake-board-row{display:block;clear:both}\\n\"], components: [{ type: TileComponent, selector: \"ngx-snake-tile\", inputs: [\"state\"] }], directives: [{ type: i2.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: BoardComponent, decorators: [{\n            type: Component,\n            args: [{ selector: 'ngx-snake-board', template: \"<div class=\\\"ngx-snake-board-row\\\" *ngFor=\\\"let row of data\\\">\\n    <ngx-snake-tile *ngFor=\\\"let tileState of row\\\"\\n                    [state]=\\\"tileState\\\"></ngx-snake-tile>\\n</div>\\n\", styles: [\":host .ngx-snake-board-row{display:block;clear:both}\\n\"] }]\n        }], ctorParameters: function () { return []; }, propDecorators: { data: [{\n                type: Input\n            }] } });\n\nclass NgxSnakeComponent {\n    constructor(_manager) {\n        this._manager = _manager;\n        this.boardHeight = 10;\n        this.boardWidth = 10;\n        this.foodEaten = this._manager.foodEaten$;\n        this.gameOver = this._manager.gameOver$;\n        this.grid$ = this._manager.grid$;\n    }\n    ngOnInit() {\n        this._manager.initialize(this.boardHeight, this.boardWidth);\n    }\n    actionUp() { this._manager.up(); }\n    actionRight() { this._manager.right(); }\n    actionDown() { this._manager.down(); }\n    actionLeft() { this._manager.left(); }\n    actionStart() {\n        this._manager.start();\n    }\n    actionStop() {\n        this._manager.pause();\n    }\n    actionReset() {\n        this._manager.reset();\n    }\n}\nNgxSnakeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeComponent, deps: [{ token: GameManagerService }], target: i0.ɵɵFactoryTarget.Component });\nNgxSnakeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.0.1\", type: NgxSnakeComponent, selector: \"ngx-snake\", inputs: { boardHeight: \"boardHeight\", boardWidth: \"boardWidth\" }, outputs: { foodEaten: \"foodEaten\", gameOver: \"gameOver\" }, ngImport: i0, template: `\n        <ngx-snake-board\n            [data]=\"grid$ | async\"></ngx-snake-board>\n    `, isInline: true, components: [{ type: BoardComponent, selector: \"ngx-snake-board\", inputs: [\"data\"] }], pipes: { \"async\": i2.AsyncPipe } });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeComponent, decorators: [{\n            type: Component,\n            args: [{\n                    selector: 'ngx-snake',\n                    template: `\n        <ngx-snake-board\n            [data]=\"grid$ | async\"></ngx-snake-board>\n    `,\n                    styles: []\n                }]\n        }], ctorParameters: function () { return [{ type: GameManagerService }]; }, propDecorators: { boardHeight: [{\n                type: Input\n            }], boardWidth: [{\n                type: Input\n            }], foodEaten: [{\n                type: Output\n            }], gameOver: [{\n                type: Output\n            }] } });\n\nclass NgxSnakeModule {\n    static forRoot() {\n        return {\n            ngModule: NgxSnakeModule\n        };\n    }\n}\nNgxSnakeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNgxSnakeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeModule, declarations: [NgxSnakeComponent,\n        BoardComponent,\n        TileComponent], imports: [CommonModule], exports: [NgxSnakeComponent] });\nNgxSnakeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeModule, providers: [\n        GameManagerService\n    ], imports: [[\n            CommonModule\n        ]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.1\", ngImport: i0, type: NgxSnakeModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [\n                        NgxSnakeComponent,\n                        BoardComponent,\n                        TileComponent\n                    ],\n                    imports: [\n                        CommonModule\n                    ],\n                    providers: [\n                        GameManagerService\n                    ],\n                    exports: [\n                        NgxSnakeComponent\n                    ]\n                }]\n        }] });\n\n/*\n * Public API Surface of ngx-snake\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgxSnakeComponent, NgxSnakeModule };\n"]},"metadata":{},"sourceType":"module"}